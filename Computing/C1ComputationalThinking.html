<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
		<script src="http://www.w3schools.com/lib/w3.js"></script>
		<link rel="stylesheet" type="text/css" href="ComputingStyleSheet.css"></link>
	</head>
	<body>
		<nav class="navbar navbar-default navbar-fixed-top">
			<div class="container-fluid">
				<div class="navbar-header">
					<a class="navbar-brand" href="https://oxyotl.github.io/">JJW E-portfolio</a>
				</div>
				<ul class="nav navbar-nav">
					<li><a href="ComputingHome.html">Computing Home</a></li>
					<li class="active"><a href="C1ComputationalThinking.html">Previous Page</a></li>
					<li><a href="C2ElementsOfComputationalThinking.html">Next Page</a></li>
				</ul>
			</div>
		</nav>
		<div class="container-fluid">
			<div class="row">
				<img src="ComputingPictures/ComputationalThinkingPicture.jpg" class="img-rounded HeaderImage">
			</div>
			<div class="row">
				<div class="col-sm-9">
					<h1>Computational Thinking</h1>
					<p>Computational thinking is a problem-solving approach that borrows techniques from computer
					science, notably abstraction, problem decomposition and the developemnt of algorithms.
					Computational thinking is applied to a wide variety of problem domains and not just to the developemnt
					of computer systems.</p>
					<h3>How Computers Help Us Think</h3>
					<ol>
						<li><p>We can get technology to do all the hard work for us, so problems in the past that involved
						too much work or time can be done very quickly. This means we have to formulate them in such a way
						to use all of the potential of a computer. We have to approach a problem differently in order to 
						get the most out of a computer system.</p></li>
						<li><p>Formulating the problem for a computer to solve helps us understand the problem better.
						We might not be able to see where the problem can be broken down into smaller parts otherwise.</p></li>
						<li><p>Understanding how computers store and process data provides us with understanding of 
						how our world works.</p></li>
					</ol>
					<h3>How We Can Use Computational Thinking</h3>
					<ul>
						<li>Look at the problem and asses how hard it is.</li>
						<li>Use recursion to apply a simple soloution repetitively.</li>
						<li>Model the problem into something familiar that you know how to solve.</li>
						<li>Model the problem so that you could create a program that a computer could run.</li>
						<li>Look at your solution to the problem and asses it's efficency.</li>
						<li>Create processes in your solution to limit damage and allow recovery from errors.</li>
						<li>Scale your solution to cope with larger problems that are similar.</li>
					<ul>
				</div>
				<div class="col-sm-3">
					<div class="KeyTerms">
						<h2>Key Terms:</h2>
						<h4>Computational Thinking</h4>
						<p>A problem-solving approach that borrows techniques from computer
						science, notably abstraction, problem decomposition and the developemnt of algorithms.</p>
					</div>
				</div>
			</div>
			<div class="row">
				<div class="col-sm-9">
					<h2>Breaking Down Problems</h2>
					<p>One benefit of thinking in computational terms is that it allows us to tackle large problems that 
					seem unsolvable, this is becasue many approaches to breaking down problems into smaller ones have 
					been developed. This is called decomposition, the aim is that the smaller problems will be easier 
					to understand and solve.<p>
					<h3>Top-down Design</h3>
					<p>Top-down design led to the widespread use of modular programming. Benefits of this is that smaller 
					programs are easier to debig than large ones, work load can be split up between programmers reducing work-load 
					of each programmer and easier use of expertise. Top-down design is a hierarchical meaning that each sub-problem 
					leads to smaller components, this can be represented in a tree like structure.</p>
					<img src="ComputingPictures/" class="img-rounded HeaderImage">
					<p>A problem with the top-down approach is that it assumes that the whole solution to the problem is 
					knowable in advance. This is not always the case and plans and ideas change as a project develops.
					Also hierarchical approach is less useful with many modern applications, with widespread adoption of 
					event-driven programming this neat drop-down system is not always appropriate.</p>
					<h3>Parallel Processes</h3>
					<p>Decomposition doesn't have to be hierarchical, it can take intoto account parallel processes whre alternative 
					paths are possible. This still helps us to break down the problem. Decomposition can be applied at various levels
					in computing scenaris. We can break down problems into different functional components that lead to modules or 
					program procedures. We can also break down a problem into processes, data stores and data flows. This approach is 
					called data-flow, and can be represented in a diagram.</p>
					<img src="ComputingPictures/" class="img-rounded HeaderImage">
					<p>The advantage of using a data-flow approach is that major components and activities of the system are laid out 
					before any of the finer details of the algorithm has been developed.</p>
					<h3>Structured Programming</h3>
					<p>In structured programming functions are only designed to do one or a limited set of jobs, this makes a program 
					easy to read. Structured programming gained favor becasue it was shown be Bohm and Jacopini in 1966 that any 
					computable function can be carried out by using one of three constructs.<p>
					<p>These three constructs are:</p>
					<ul><li><p>Sequence - Executing one statement after another.</p></li>
						<li><p>Selection - Branching to a different place in a program according to the value of a Boolean expression.</p></li>
						<li><p>Iteration - Repeating a section of code until a Boolean expression is true.</p></li>
					</ul>
					<h3>Objects</h3>
					<p>Object-oriented programming is a common way of braking down problems and functionality at the same time. An object, which 
					is based on a class, is a container of attributes (data) and methods (code). The benefits of OOP is that each object is isolated
					from others which minimises errors due to interference and also allows the reuse of objects for similar problems.</p>
				</div>
				<div class="col-sm-3">
					<div class="KeyTerms">
						<h2>Key Terms:</h2>
						<h4>Decomposition</h4>
						<p>The breaking down of a problem into smaller parts that are easier to solve.</p><br>
						<h4>Object-oriented Programming</h4>
						<p>A program made up of custom-made data structures to represent often-used real-world 
						entities that interact with each other.</p>
					</div>
					<div class="KeyPoints">
						<h2>Key Points:</h2>
						<P>Structured programming remains one of the key factors that affects the way in which 
						your practical programming course work is marked and judged.</p>
						<p>Many ways of decomposition have been developed.</p>
						<p>We can use decomposition to solve many everday problems.</p>
					</div>
				</div>
			</div>
			<div class="row">
				<div class="col-sm-9">
					<h2>The Power of Algorithms</h2>
					<p>An algorithm in it's simplest form is a procedure, for example a baker get the ingredients to make a loaf of bread as an input, 
					carries out processes (procedures) on them as an algorithm and outputs a loaf of bread.<p>
					<p>Devising algorithms is an important and long-standing part of computational thinking. The development of computers has highlighted 
					the importance and centrality of algorithms in all problem solving.</p>
					<p>Creating algorithms is very hard to do, for most non-trivial problems there can be multiple ways of solving them. Even after a system 
					has been implemented usually there are better algorithms can be used, making the system more robust, easier to use, run faster or use 
					fewer resources.</p>
					<p>The power of algorithms comes from te short cuts that have been built into them, this in turn come form a proper decomposition of the 
					problem in the first place. Some of the most effective algorithms are based on repeating simple processes.</p>
					<p>Algorithms can't work on their own, they are designed to do something with to or with data. If the data has been structured this makes 
					devising an algorithm much easier.</p>
					<p>When designing algorithms you need to bear certain things in mind:</p>
					<ol><li><p>Algorithms must exactly describe what they are supposed to do. Any ambiguity will make the algorithm unreliable when implemented</p></li>
						<li><p>Algorithms must end, no end means no result. With algorithms that iterate you must put an end condition.</p></li>
						<li><p>Algorithms must be correct, there is no point in running an algorithm if the output is incorrect.</p></li>
						<li><p>Algorithms must work with any instances of the same problem, this is the whole point of an algorithm so that the same problem can 
						be solved on differnet data sets.</p></li>
					</ol>
					<p>Once an algorithm has been designed all that is left to do is to code it into a programming language.</p>
				</div>
				<div class="col-sm-3">
					<div class="KeyPoints">
						<h2>Key Points:</h2>
						<p>Algorithms are an integeral part of the decompositon process.</p>
						<p>Small problems extracted from big problems should be solvable by an algorithm.</p>
						<p>Recursive algorithms are useful for solving simple problems that may have any number of iterations.</p>
					</div>
				</div>
			</div>
		</div>
	</body>
</html>
